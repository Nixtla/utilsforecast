



# <kbd>module</kbd> `utilsforecast.processing`





---



## <kbd>function</kbd> `to_numpy`

```python
to_numpy(df: Union[DataFrame, DataFrame]) → ndarray
```






---



## <kbd>function</kbd> `counts_by_id`

```python
counts_by_id(
    df: Union[DataFrame, DataFrame],
    id_col: str
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `maybe_compute_sort_indices`

```python
maybe_compute_sort_indices(
    df: Union[DataFrame, DataFrame],
    id_col: str,
    time_col: str
) → Optional[ndarray]
```

Compute indices that would sort the dataframe 



**Args:**
 
 - <b>`df`</b> (pandas or polars DataFrame):  Input dataframe with id, times and target values. 



**Returns:**
 
 - <b>`numpy array or None`</b>:  Array with indices to sort the dataframe or None if it's already sorted. 


---



## <kbd>function</kbd> `assign_columns`

```python
assign_columns(
    df: Union[DataFrame, DataFrame],
    names: Union[str, List[str]],
    values: Union[ndarray, Series, Series, List[float]]
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `drop_columns`

```python
drop_columns(
    df: Union[DataFrame, DataFrame],
    columns: Union[str, List[str]]
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `take_rows`

```python
take_rows(
    df: Union[DataFrame, DataFrame, Series, Series, ndarray],
    idxs: ndarray
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `filter_with_mask`

```python
filter_with_mask(
    df: Union[Series, Series, DataFrame, DataFrame, Index, ndarray],
    mask: Union[ndarray, Series, Series]
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `is_nan`

```python
is_nan(s: Union[Series, Series]) → Union[Series, Series]
```






---



## <kbd>function</kbd> `is_none`

```python
is_none(s: Union[Series, Series]) → Union[Series, Series]
```






---



## <kbd>function</kbd> `is_nan_or_none`

```python
is_nan_or_none(s: Union[Series, Series]) → Union[Series, Series]
```






---



## <kbd>function</kbd> `match_if_categorical`

```python
match_if_categorical(
    s1: Union[Series, Series, Index],
    s2: Union[Series, Series]
) → Tuple[Union[Series, Series], Union[Series, Series]]
```






---



## <kbd>function</kbd> `vertical_concat`

```python
vertical_concat(
    dfs: List[Union[DataFrame, DataFrame, Series, Series]],
    match_categories: bool = True
) → Union[DataFrame, DataFrame, Series, Series]
```






---



## <kbd>function</kbd> `horizontal_concat`

```python
horizontal_concat(
    dfs: List[Union[DataFrame, DataFrame]]
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `copy_if_pandas`

```python
copy_if_pandas(
    df: Union[DataFrame, DataFrame],
    deep: bool = False
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `join`

```python
join(
    df1: Union[DataFrame, DataFrame, Series, Series],
    df2: Union[DataFrame, DataFrame, Series, Series],
    on: Union[str, List[str]],
    how: str = 'inner'
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `drop_index_if_pandas`

```python
drop_index_if_pandas(
    df: Union[DataFrame, DataFrame]
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `rename`

```python
rename(
    df: Union[DataFrame, DataFrame],
    mapping: Dict[str, str]
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `sort`

```python
sort(
    df: Union[DataFrame, DataFrame],
    by: Optional[str, List[str]] = None
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `offset_times`

```python
offset_times(
    times: Union[Series, Series, Index],
    freq: Union[int, str, BaseOffset],
    n: Union[int, ndarray]
) → Union[Series, Series, Index]
```






---



## <kbd>function</kbd> `offset_dates`

```python
offset_dates(
    dates: Union[Series, Series, Index],
    freq: Union[int, str, BaseOffset],
    n: Union[int, Series, Series]
) → Union[Series, Series, Index]
```






---



## <kbd>function</kbd> `time_ranges`

```python
time_ranges(
    starts: Union[Series, Series, Index],
    freq: Union[int, str, BaseOffset],
    periods: int
) → Union[Series, Series]
```






---



## <kbd>function</kbd> `repeat`

```python
repeat(
    s: Union[Series, Series, Index, ndarray],
    n: Union[int, ndarray, Series, Series]
) → Union[Series, Series, Index, ndarray]
```






---



## <kbd>function</kbd> `cv_times`

```python
cv_times(
    times: ndarray,
    uids: Union[Series, Series, Index],
    indptr: ndarray,
    h: int,
    test_size: int,
    step_size: int,
    id_col: str = 'unique_id',
    time_col: str = 'ds'
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `group_by`

```python
group_by(
    df: Union[Series, Series, DataFrame, DataFrame],
    by,
    maintain_order=False
)
```






---



## <kbd>function</kbd> `group_by_agg`

```python
group_by_agg(
    df: Union[DataFrame, DataFrame],
    by,
    aggs,
    maintain_order=False
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `is_in`

```python
is_in(s: Union[Series, Series], collection) → Union[Series, Series]
```






---



## <kbd>function</kbd> `between`

```python
between(
    s: Union[Series, Series],
    lower: Union[Series, Series],
    upper: Union[Series, Series]
) → Union[Series, Series]
```






---



## <kbd>function</kbd> `fill_null`

```python
fill_null(
    df: Union[DataFrame, DataFrame],
    mapping: Dict[str, Any]
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `cast`

```python
cast(s: Union[Series, Series], dtype: type) → Union[Series, Series]
```






---



## <kbd>function</kbd> `value_cols_to_numpy`

```python
value_cols_to_numpy(
    df: Union[DataFrame, DataFrame],
    id_col: str,
    time_col: str,
    target_col: Optional[str]
) → ndarray
```






---



## <kbd>function</kbd> `make_future_dataframe`

```python
make_future_dataframe(
    uids: Union[Series, Series],
    last_times: Union[Series, Series, Index],
    freq: Union[int, str, BaseOffset],
    h: int,
    id_col: str = 'unique_id',
    time_col: str = 'ds'
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `anti_join`

```python
anti_join(
    df1: Union[DataFrame, DataFrame],
    df2: Union[DataFrame, DataFrame],
    on: Union[str, List[str]]
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `ensure_sorted`

```python
ensure_sorted(
    df: Union[DataFrame, DataFrame],
    id_col: str,
    time_col: str
) → Union[DataFrame, DataFrame]
```






---



## <kbd>function</kbd> `process_df`

```python
process_df(
    df: Union[DataFrame, DataFrame],
    id_col: str,
    time_col: str,
    target_col: Optional[str]
) → ProcessedDF
```

Extract components from dataframe 



**Args:**
 
 - <b>`df`</b> (pandas or polars DataFrame):  Input dataframe with id, times and target values. 



**Returns:**
 
 - <b>`ProcessedDF`</b>:  A named tuple containing: 
        - ids (pandas or polars Series): serie with the sorted unique ids present in the data. 
        - last_times (numpy array): array with the last time for each serie. 
        - data (numpy ndarray): 2d array with target plus features values. 
        - indptr (numpy ndarray): 1d array with indices to the start and end of each serie. 
        - sort_idxs (numpy array or None): array with the indices that would sort the original data.  If the data is already sorted this is `None`. 


---



## <kbd>function</kbd> `backtest_splits`

```python
backtest_splits(
    df: Union[DataFrame, DataFrame],
    n_windows: int,
    h: int,
    id_col: str,
    time_col: str,
    freq: Union[int, str, BaseOffset],
    step_size: Optional[int] = None,
    input_size: Optional[int] = None,
    allow_partial_horizons: bool = False
) → Generator[Tuple[Union[DataFrame, DataFrame], Union[DataFrame, DataFrame], Union[DataFrame, DataFrame]], NoneType, NoneType]
```






---



## <kbd>function</kbd> `add_insample_levels`

```python
add_insample_levels(
    df: Union[DataFrame, DataFrame],
    models: List[str],
    level: List[Union[int, float]],
    id_col: str = 'unique_id',
    target_col: str = 'y'
) → Union[DataFrame, DataFrame]
```






---



## <kbd>class</kbd> `ProcessedDF`
ProcessedDF(uids, last_times, data, indptr, sort_idxs) 





---



## <kbd>class</kbd> `DataFrameProcessor`






### <kbd>method</kbd> `__init__`

```python
__init__(id_col: str = 'unique_id', time_col: str = 'ds', target_col: str = 'y')
```








---



### <kbd>method</kbd> `process`

```python
process(
    df: Union[DataFrame, DataFrame]
) → Tuple[Union[Series, Series], ndarray, ndarray, ndarray, Optional[ndarray]]
```






