# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/target_transforms.ipynb.

# %% auto 0
__all__ = ['BaseTargetTransform', 'LocalStandardScaler']

# %% ../nbs/target_transforms.ipynb 3
import abc
from typing import Tuple

try:
    from numba import njit
except ImportError:
    raise ImportError(
        "Please install numba. "
        "You can find detailed instructions at https://numba.pydata.org/numba-doc/latest/user/installing.html"
    )
import numpy as np

from .grouped_array import GroupedArray

# %% ../nbs/target_transforms.ipynb 4
class BaseTargetTransform(abc.ABC):
    """Base class used for target transformations."""

    @abc.abstractmethod
    def fit_transform(self, ga: GroupedArray) -> np.ndarray:
        raise NotImplementedError

    @abc.abstractmethod
    def inverse_transform(self, ga: GroupedArray) -> np.ndarray:
        raise NotImplementedError

# %% ../nbs/target_transforms.ipynb 5
@njit
def _standard_scaler_transform(
    data: np.ndarray, indptr: np.ndarray
) -> Tuple[np.ndarray, np.ndarray]:
    n_groups = len(indptr) - 1
    stats = np.empty((n_groups, 2))
    out = np.empty_like(data)
    for i in range(n_groups):
        sl = slice(indptr[i], indptr[i + 1])
        mean = np.mean(data[sl])
        std = np.std(data[sl])
        stats[i, :] = mean, std
        out[sl] = (data[sl] - mean) / std
    return out, stats


@njit
def _standard_scaler_inverse_transform(
    data: np.ndarray,
    indptr: np.ndarray,
    stats: np.ndarray,
) -> np.ndarray:
    n_groups = len(indptr) - 1
    out = np.empty_like(data)
    for i in range(n_groups):
        sl = slice(indptr[i], indptr[i + 1])
        mean, std = stats[i]
        out[sl] = data[sl] * std + mean
    return out

# %% ../nbs/target_transforms.ipynb 6
class LocalStandardScaler(BaseTargetTransform):
    """Standardizes each serie by subtracting its mean and dividing by its standard deviation."""

    def fit_transform(self, ga: GroupedArray) -> np.ndarray:
        transformed, self.stats_ = _standard_scaler_transform(ga.data, ga.indptr)
        return transformed

    def inverse_transform(self, ga: GroupedArray) -> np.ndarray:
        return _standard_scaler_inverse_transform(ga.data, ga.indptr, self.stats_)
