# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/target_transforms.ipynb.

# %% auto 0
__all__ = ['BaseTargetTransform', 'LocalStandardScaler']

# %% ../nbs/target_transforms.ipynb 3
import abc
from typing import Optional

import numpy as np
import pandas as pd

# %% ../nbs/target_transforms.ipynb 4
def _ensure_shallow_copy(df: pd.DataFrame) -> pd.DataFrame:
    from packaging.version import Version

    if Version(pd.__version__) < Version("1.4"):
        # https://github.com/pandas-dev/pandas/pull/43406
        df = df.copy()
    return df

# %% ../nbs/target_transforms.ipynb 5
class BaseTargetTransform(abc.ABC):
    """Base class used for target transformations."""

    idxs: Optional[np.ndarray] = None

    def set_column_names(self, id_col: str, time_col: str, target_col: str):
        self.id_col = id_col
        self.time_col = time_col
        self.target_col = target_col

    @abc.abstractmethod
    def fit_transform(self, df: pd.DataFrame) -> pd.DataFrame:
        raise NotImplementedError

    @abc.abstractmethod
    def inverse_transform(self, df: pd.DataFrame) -> pd.DataFrame:
        raise NotImplementedError

    def inverse_transform_fitted(
        self, df: pd.DataFrame, _sizes: np.ndarray
    ) -> pd.DataFrame:
        return self.inverse_transform(df)

# %% ../nbs/target_transforms.ipynb 6
class LocalStandardScaler(BaseTargetTransform):
    """Standardizes each serie by subtracting its mean and dividing by its standard deviation."""

    def fit_transform(self, df: pd.DataFrame) -> pd.DataFrame:
        stats = df.groupby(self.id_col, observed=True)[self.target_col].agg(
            ["size", "mean", "std"]
        )
        sizes = stats["size"].values
        self.stats_ = stats[["mean", "std"]].values
        bc_stats = np.repeat(self.stats_, sizes, axis=0)
        df = df.copy(deep=False)
        df = _ensure_shallow_copy(df)
        df[self.target_col] = (df[self.target_col].values - bc_stats[:, 0]) / bc_stats[
            :, 1
        ]
        return df

    def _invert_with_stats(
        self, df: pd.DataFrame, bc_stats: np.ndarray
    ) -> pd.DataFrame:
        df = df.copy(deep=False)
        df = _ensure_shallow_copy(df)
        model_cols = df.columns.drop([self.id_col, self.time_col])
        for model in model_cols:
            df[model] = df[model].values * bc_stats[:, 1] + bc_stats[:, 0]
        return df

    def inverse_transform(self, df: pd.DataFrame) -> pd.DataFrame:
        stats = self.stats_
        if self.idxs is not None:
            stats = stats[self.idxs]
        h = df.shape[0] // stats.shape[0]
        bc_stats = np.repeat(stats, h, axis=0)
        return self._invert_with_stats(df, bc_stats)

    def inverse_transform_fitted(
        self, df: pd.DataFrame, sizes: np.ndarray
    ) -> pd.DataFrame:
        bc_stats = np.repeat(self.stats_, sizes, axis=0)
        return self._invert_with_stats(df, bc_stats)
