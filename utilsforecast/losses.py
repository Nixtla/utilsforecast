# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/losses.ipynb.

# %% auto 0
__all__ = ['mae', 'mse', 'rmse', 'bias', 'mape', 'smape', 'mase', 'rmae', 'quantile_loss', 'mqloss', 'coverage', 'calibration',
           'scaled_crps']

# %% ../nbs/losses.ipynb 3
from typing import Callable, Dict, List, Optional, Tuple, Union

import numpy as np
import pandas as pd

import utilsforecast.processing as ufp
from .compat import DFType, DataFrame, pl_DataFrame, pl, pl_Expr

# %% ../nbs/losses.ipynb 11
def _base_docstring(*args, **kwargs) -> Callable:
    base_docstring = """

    Parameters
    ----------
    df : pandas or polars DataFrame
        Input dataframe with id, actual values and predictions.
    models : list of str
        Columns that identify the models predictions.
    id_col : str (default='unique_id')
        Column that identifies each serie.
    target_col : str (default='y')
        Column that contains the target.

    Returns
    -------
    pandas or polars Dataframe
        dataframe with one row per id and one column per model.
    """

    def docstring_decorator(f: Callable):
        if f.__doc__ is not None:
            f.__doc__ += base_docstring
        return f

    return docstring_decorator(*args, **kwargs)

# %% ../nbs/losses.ipynb 12
def _pl_agg_expr(
    df: pl_DataFrame,
    models: Union[List[str], List[Tuple[str, str]]],
    id_col: str,
    gen_expr: Callable[[Union[str, Tuple[str, str]]], "pl.Expr"],
) -> pl_DataFrame:
    exprs = [gen_expr(model) for model in models]
    df = df.select([id_col, *exprs])
    return ufp.group_by(df, id_col, maintain_order=True).mean()

# %% ../nbs/losses.ipynb 13
@_base_docstring
def mae(
    df: DFType,
    models: List[str],
    id_col: str = "unique_id",
    target_col: str = "y",
) -> DFType:
    """Mean Absolute Error (MAE)

    MAE measures the relative prediction
    accuracy of a forecasting method by calculating the
    deviation of the prediction and the true
    value at a given time and averages these devations
    over the length of the series."""
    if isinstance(df, pd.DataFrame):
        res = (
            (df[models].sub(df[target_col], axis=0))
            .abs()
            .groupby(df[id_col], observed=True)
            .mean()
        )
        res.index.name = id_col
        res = res.reset_index()
    else:

        def gen_expr(model):
            return pl.col(target_col).sub(pl.col(model)).abs().alias(model)

        res = _pl_agg_expr(df, models, id_col, gen_expr)
    return res

# %% ../nbs/losses.ipynb 19
@_base_docstring
def mse(
    df: DFType,
    models: List[str],
    id_col: str = "unique_id",
    target_col: str = "y",
) -> DFType:
    """Mean Squared Error (MSE)

    MSE measures the relative prediction
    accuracy of a forecasting method by calculating the
    squared deviation of the prediction and the true
    value at a given time, and averages these devations
    over the length of the series."""
    if isinstance(df, pd.DataFrame):
        res = (
            (df[models].sub(df[target_col], axis=0))
            .pow(2)
            .groupby(df[id_col], observed=True)
            .mean()
        )
        res.index.name = id_col
        res = res.reset_index()
    else:

        def gen_expr(model):
            return pl.col(target_col).sub(pl.col(model)).pow(2).alias(model)

        res = _pl_agg_expr(df, models, id_col, gen_expr)
    return res

# %% ../nbs/losses.ipynb 24
@_base_docstring
def rmse(
    df: DFType,
    models: List[str],
    id_col: str = "unique_id",
    target_col: str = "y",
) -> DFType:
    """Root Mean Squared Error (RMSE)

    RMSE measures the relative prediction
    accuracy of a forecasting method by calculating the squared deviation
    of the prediction and the observed value at a given time and
    averages these devations over the length of the series.
    Finally the RMSE will be in the same scale
    as the original time series so its comparison with other
    series is possible only if they share a common scale.
    RMSE has a direct connection to the L2 norm."""
    res = mse(df, models, id_col, target_col)
    if isinstance(res, pd.DataFrame):
        res[models] = res[models].pow(0.5)
    else:
        res = res.with_columns(*[pl.col(c).pow(0.5) for c in models])
    return res

# %% ../nbs/losses.ipynb 27
@_base_docstring
def bias(
    df: DFType,
    models: List[str],
    id_col: str = "unique_id",
    target_col: str = "y",
) -> DFType:
    """Forecast estimator bias.

    Defined as prediction - actual"""
    if isinstance(df, pd.DataFrame):
        res = (
            (df[models].sub(df[target_col], axis=0))
            .groupby(df[id_col], observed=True)
            .mean()
        )
        res.index.name = id_col
        res = res.reset_index()
    else:

        def gen_expr(model):
            return pl.col(model).sub(pl.col(target_col)).alias(model)

        res = _pl_agg_expr(df, models, id_col, gen_expr)
    return res

# %% ../nbs/losses.ipynb 33
def _zero_to_nan(series: Union[pd.Series, "pl.Expr"]) -> Union[pd.Series, "pl.Expr"]:
    if isinstance(series, pd.Series):
        res = series.replace(0, np.nan)
    else:
        res = pl.when(series == 0).then(float("nan")).otherwise(series.abs())
    return res

# %% ../nbs/losses.ipynb 34
@_base_docstring
def mape(
    df: DFType,
    models: List[str],
    id_col: str = "unique_id",
    target_col: str = "y",
) -> DFType:
    """Mean Absolute Percentage Error (MAPE)

    MAPE measures the relative prediction
    accuracy of a forecasting method by calculating the percentual deviation
    of the prediction and the observed value at a given time and
    averages these devations over the length of the series.
    The closer to zero an observed value is, the higher penalty MAPE loss
    assigns to the corresponding error."""
    if isinstance(df, pd.DataFrame):
        res = (
            df[models]
            .sub(df[target_col], axis=0)
            .abs()
            .div(_zero_to_nan(df[target_col].abs()), axis=0)
            .groupby(df[id_col], observed=True)
            .mean()
        )
        res.index.name = id_col
        res = res.reset_index()
    else:

        def gen_expr(model):
            abs_err = pl.col(target_col).sub(pl.col(model)).abs()
            abs_target = _zero_to_nan(pl.col(target_col))
            ratio = abs_err.truediv(abs_target).alias(model)
            return ratio.fill_nan(None)

        res = _pl_agg_expr(df, models, id_col, gen_expr)
    return res

# %% ../nbs/losses.ipynb 38
@_base_docstring
def smape(
    df: DFType,
    models: List[str],
    id_col: str = "unique_id",
    target_col: str = "y",
) -> DFType:
    """Symmetric Mean Absolute Percentage Error (SMAPE)

    SMAPE measures the relative prediction
    accuracy of a forecasting method by calculating the relative deviation
    of the prediction and the observed value scaled by the sum of the
    absolute values for the prediction and observed value at a
    given time, then averages these devations over the length
    of the series. This allows the SMAPE to have bounds between
    0% and 100% which is desirable compared to normal MAPE that
    may be undetermined when the target is zero."""
    if isinstance(df, pd.DataFrame):
        delta_y = df[models].sub(df[target_col], axis=0).abs()
        scale = df[models].abs().add(df[target_col].abs(), axis=0)
        raw = delta_y.div(scale).fillna(0)
        res = raw.groupby(df[id_col], observed=True).mean()
        res.index.name = id_col
        res = res.reset_index()
    else:

        def gen_expr(model):
            abs_err = pl.col(model).sub(pl.col(target_col)).abs()
            denominator = _zero_to_nan(
                pl.col(model).abs().add(pl.col(target_col)).abs()
            )
            ratio = abs_err.truediv(denominator).alias(model)
            return ratio.fill_nan(0)

        res = _pl_agg_expr(df, models, id_col, gen_expr)
    return res

# %% ../nbs/losses.ipynb 44
def mase(
    df: DFType,
    models: List[str],
    seasonality: int,
    train_df: DFType,
    id_col: str = "unique_id",
    target_col: str = "y",
) -> DFType:
    """Mean Absolute Scaled Error (MASE)

    MASE measures the relative prediction
    accuracy of a forecasting method by comparinng the mean absolute errors
    of the prediction and the observed value against the mean
    absolute errors of the seasonal naive model.
    The MASE partially composed the Overall Weighted Average (OWA),
    used in the M4 Competition.

    Parameters
    ----------
    df : pandas or polars DataFrame
        Input dataframe with id, actuals and predictions.
    models : list of str
        Columns that identify the models predictions.
    seasonality : int
        Main frequency of the time series;
        Hourly 24, Daily 7, Weekly 52, Monthly 12, Quarterly 4, Yearly 1.
    train_df : pandas or polars DataFrame
        Training dataframe with id and actual values. Must be sorted by time.
    id_col : str (default='unique_id')
        Column that identifies each serie.
    target_col : str (default='y')
        Column that contains the target.

    Returns
    -------
    pandas or polars Dataframe
        dataframe with one row per id and one column per model.

    References
    ----------
    [1] https://robjhyndman.com/papers/mase.pdf
    """
    mean_abs_err = mae(df, models, id_col, target_col)
    if isinstance(train_df, pd.DataFrame):
        mean_abs_err = mean_abs_err.set_index(id_col)
        # assume train_df is sorted
        lagged = train_df.groupby(id_col, observed=True)[target_col].shift(seasonality)
        scale = train_df[target_col].sub(lagged).abs()
        scale = scale.groupby(train_df[id_col], observed=True).mean()
        res = mean_abs_err.div(_zero_to_nan(scale), axis=0).fillna(0)
        res.index.name = id_col
        res = res.reset_index()
    else:
        # assume train_df is sorted
        lagged = pl.col(target_col).shift(seasonality).over(id_col)
        scale_expr = pl.col(target_col).sub(lagged).abs().alias("scale")
        scale = train_df.select([id_col, scale_expr])
        scale = ufp.group_by(scale, id_col).mean()
        scale = scale.with_columns(_zero_to_nan(pl.col("scale")))

        def gen_expr(model):
            return pl.col(model).truediv(pl.col("scale")).fill_nan(0).alias(model)

        full_df = mean_abs_err.join(scale, on=id_col, how="left")
        res = _pl_agg_expr(full_df, models, id_col, gen_expr)
    return res

# %% ../nbs/losses.ipynb 49
def rmae(
    df: DFType,
    models: List[str],
    baseline: str,
    id_col: str = "unique_id",
    target_col: str = "y",
) -> DFType:
    """Relative Mean Absolute Error (RMAE)

    Calculates the RAME between two sets of forecasts (from two different forecasting methods).
    A number smaller than one implies that the forecast in the
    numerator is better than the forecast in the denominator.

    Parameters
    ----------
    df : pandas or polars DataFrame
        Input dataframe with id, times, actuals and predictions.
    models : list of str
        Columns that identify the models predictions.
    baseline : str
        Column that identifies the baseline model predictions.
    id_col : str (default='unique_id')
        Column that identifies each serie.
    target_col : str (default='y')
        Column that contains the target.

    Returns
    -------
    pandas or polars Dataframe
        dataframe with one row per id and one column per model.
    """
    numerator = mae(df, models, id_col, target_col)
    denominator = mae(df, [baseline], id_col, target_col)
    if ufp.is_nan(denominator[baseline]).any():
        raise ValueError(f"baseline model ({baseline}) contains NaNs.")
    denominator = ufp.rename(denominator, {baseline: f"{baseline}_denominator"})
    res = ufp.join(numerator, denominator, on=id_col)
    if isinstance(numerator, pd.DataFrame):
        for model in models:
            res[model] = (
                res[model].div(_zero_to_nan(res[f"{baseline}_denominator"])).fillna(0)
            )
        res = res[[id_col, *models]]
    else:

        def gen_expr(model, baseline) -> pl_Expr:
            denominator = _zero_to_nan(pl.col(f"{baseline}_denominator"))
            return pl.col(model).truediv(denominator).fill_nan(0).alias(model)

        exprs: List[pl_Expr] = [gen_expr(m, baseline) for m in models]
        res = res.select([id_col, *exprs])
    return res

# %% ../nbs/losses.ipynb 55
def quantile_loss(
    df: DFType,
    models: Dict[str, str],
    q: float = 0.5,
    id_col: str = "unique_id",
    target_col: str = "y",
) -> DFType:
    """Quantile Loss (QL)

    QL measures the deviation of a quantile forecast.
    By weighting the absolute deviation in a non symmetric way, the
    loss pays more attention to under or over estimation.
    A common value for q is 0.5 for the deviation from the median.

    Parameters
    ----------
    df : pandas or polars DataFrame
        Input dataframe with id, times, actuals and predictions.
    models : dict from str to str
        Mapping from model name to the model predictions for the specified quantile.
    q : float (default=0.5)
        Quantile for the predictions' comparison.
    id_col : str (default='unique_id')
        Column that identifies each serie.
    target_col : str (default='y')
        Column that contains the target.

    Returns
    -------
    pandas or polars Dataframe
        dataframe with one row per id and one column per model.
    """
    if isinstance(df, pd.DataFrame):
        res: Optional[pd.DataFrame] = None
        for model_name, pred_col in models.items():
            delta_y = df[target_col].sub(df[pred_col], axis=0)
            model_res = (
                np.maximum(q * delta_y, (q - 1) * delta_y)
                .groupby(df[id_col], observed=True)
                .mean()
                .rename(model_name)
                .reset_index()
            )
            if res is None:
                res = model_res
            else:
                res[model_name] = model_res[model_name]
    else:

        def gen_expr(model):
            model_name, pred_col = model
            delta_y = pl.col(target_col).sub(pl.col(pred_col))
            try:
                col_max = pl.max_horizontal([q * delta_y, (q - 1) * delta_y])
            except AttributeError:
                col_max = pl.max([q * delta_y, (q - 1) * delta_y])
            return col_max.alias(model_name)

        res = _pl_agg_expr(df, list(models.items()), id_col, gen_expr)
    return res

# %% ../nbs/losses.ipynb 61
def mqloss(
    df: DFType,
    models: Dict[str, List[str]],
    quantiles: np.ndarray,
    id_col: str = "unique_id",
    target_col: str = "y",
) -> DFType:
    """Multi-Quantile loss (MQL)

    MQL calculates the average multi-quantile Loss for
    a given set of quantiles, based on the absolute
    difference between predicted quantiles and observed values.

    The limit behavior of MQL allows to measure the accuracy
    of a full predictive distribution $\mathbf{\hat{F}}_{\\tau}$ with
    the continuous ranked probability score (CRPS). This can be achieved
    through a numerical integration technique, that discretizes the quantiles
    and treats the CRPS integral with a left Riemann approximation, averaging over
    uniformly distanced quantiles.

    Parameters
    ----------
    df : pandas or polars DataFrame
        Input dataframe with id, times, actuals and predictions.
    models : dict from str to list of str
        Mapping from model name to the model predictions for each quantile.
    quantiles : numpy array
        Quantiles to compare against.
    id_col : str (default='unique_id')
        Column that identifies each serie.
    target_col : str (default='y')
        Column that contains the target.

    Returns
    -------
    pandas or polars Dataframe
        dataframe with one row per id and one column per model.

    References
    ----------
    [1] https://www.jstor.org/stable/2629907
    """
    res: Optional[DataFrame] = None
    error = np.empty((df.shape[0], quantiles.size))
    for model, predictions in models.items():
        for j, q_preds in enumerate(predictions):
            error[:, j] = (df[target_col] - df[q_preds]).to_numpy()
        loss = np.maximum(error * quantiles, error * (quantiles - 1)).mean(axis=1)
        model_res = type(df)({id_col: df[id_col], model: loss})
        model_res = ufp.group_by_agg(
            model_res, by=id_col, aggs={model: "mean"}, maintain_order=True
        )
        if res is None:
            res = model_res
        else:
            res = ufp.assign_columns(res, model, model_res[model])
    return res

# %% ../nbs/losses.ipynb 67
def coverage(
    df: DFType,
    models: List[str],
    level: int,
    id_col: str = "unique_id",
    target_col: str = "y",
) -> DFType:
    """Coverage of y with y_hat_lo and y_hat_hi.

    Parameters
    ----------
    df : pandas or polars DataFrame
        Input dataframe with id, times, actuals and predictions.
    models : list of str
        Columns that identify the models predictions.
    level : int
        Confidence level used for intervals.
    id_col : str (default='unique_id')
        Column that identifies each serie.
    target_col : str (default='y')
        Column that contains the target.

    Returns
    -------
    pandas or polars Dataframe
        dataframe with one row per id and one column per model.

    References
    ----------
    [1] https://www.jstor.org/stable/2629907
    """
    if isinstance(df, pd.DataFrame):
        out = np.empty((df.shape[0], len(models)))
        for j, model in enumerate(models):
            out[:, j] = df[target_col].between(
                df[f"{model}-lo-{level}"], df[f"{model}-hi-{level}"]
            )
        res = (
            pd.DataFrame(out, columns=models, index=df.index)
            .groupby(df[id_col], observed=True)
            .mean()
        )
        res.index.name = id_col
        res = res.reset_index()
    else:

        def gen_expr(model):
            return (
                pl.col(target_col)
                .is_between(
                    pl.col(f"{model}-lo-{level}"), pl.col(f"{model}-hi-{level}")
                )
                .alias(model)
            )

        res = _pl_agg_expr(df, models, id_col, gen_expr)
    return res

# %% ../nbs/losses.ipynb 71
def calibration(
    df: DFType,
    models: Dict[str, str],
    id_col: str = "unique_id",
    target_col: str = "y",
) -> DFType:
    """
    Fraction of y that is lower than the model's predictions.

    Parameters
    ----------
    df : pandas or polars DataFrame
        Input dataframe with id, times, actuals and predictions.
    models : dict from str to str
        Mapping from model name to the model predictions.
    id_col : str (default='unique_id')
        Column that identifies each serie.
    target_col : str (default='y')
        Column that contains the target.

    Returns
    -------
    pandas or polars Dataframe
        dataframe with one row per id and one column per model.

    References
    ----------
    [1] https://www.jstor.org/stable/2629907
    """
    if isinstance(df, pd.DataFrame):
        out = np.empty((df.shape[0], len(models)))
        for j, q_preds in enumerate(models.values()):
            out[:, j] = df[target_col].le(df[q_preds])
        res = (
            pd.DataFrame(out, columns=models.keys(), index=df.index)
            .groupby(df[id_col], observed=True)
            .mean()
        )
        res.index.name = id_col
        res = res.reset_index()
    else:

        def gen_expr(model):
            model_name, q_preds = model
            return pl.col(target_col).le(pl.col(q_preds)).alias(model_name)

        res = _pl_agg_expr(df, list(models.items()), id_col, gen_expr)
    return res

# %% ../nbs/losses.ipynb 75
def scaled_crps(
    df: DFType,
    models: Dict[str, List[str]],
    quantiles: np.ndarray,
    id_col: str = "unique_id",
    target_col: str = "y",
) -> DFType:
    """Scaled Continues Ranked Probability Score

    Calculates a scaled variation of the CRPS, as proposed by Rangapuram (2021),
    to measure the accuracy of predicted quantiles `y_hat` compared to the observation `y`.
    This metric averages percentual weighted absolute deviations as
    defined by the quantile losses.

    Parameters
    ----------
    df : pandas or polars DataFrame
        Input dataframe with id, times, actuals and predictions.
    models : dict from str to list of str
        Mapping from model name to the model predictions for each quantile.
    quantiles : numpy array
        Quantiles to compare against.
    id_col : str (default='unique_id')
        Column that identifies each serie.
    target_col : str (default='y')
        Column that contains the target.

    Returns
    -------
    pandas or polars Dataframe
        dataframe with one row per id and one column per model.

    References
    ----------
    [1] https://proceedings.mlr.press/v139/rangapuram21a.html
    """
    eps: np.float64 = np.finfo(np.float64).eps
    quantiles = np.asarray(quantiles)
    loss = mqloss(df, models, quantiles, id_col, target_col)
    sizes = ufp.counts_by_id(df, id_col)
    if isinstance(loss, pd.DataFrame):
        loss = loss.set_index(id_col)
        sizes = sizes.set_index(id_col)
        assert isinstance(df, pd.DataFrame)
        norm = df[target_col].abs().groupby(df[id_col], observed=True).sum()
        res = 2 * loss.mul(sizes["counts"], axis=0).div(norm + eps, axis=0)
        res.index.name = id_col
        res = res.reset_index()
    else:

        def gen_expr(model):
            return (
                2 * pl.col(model) * pl.col("counts") / (pl.col("norm") + eps)
            ).alias(model)

        grouped_df = ufp.group_by(df, id_col)
        norm = grouped_df.agg(pl.col(target_col).abs().sum().alias("norm"))
        res = _pl_agg_expr(
            loss.join(sizes, on=id_col).join(norm, on=id_col),
            list(models.keys()),
            id_col,
            gen_expr,
        )
    return res
