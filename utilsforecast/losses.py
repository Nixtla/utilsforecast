# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/losses.ipynb.

# %% auto 0
__all__ = ['mae', 'mse', 'rmse', 'mape', 'smape', 'mase', 'rmae', 'quantile_loss', 'mqloss', 'coverage', 'calibration',
           'scaled_crps']

# %% ../nbs/losses.ipynb 3
from typing import Optional, Union

import numpy as np

# %% ../nbs/losses.ipynb 6
def _divide_no_nan(a: np.ndarray, b: np.ndarray) -> np.ndarray:
    """Auxiliary funtion to handle divide by 0"""
    out_dtype = np.result_type(np.float32, a.dtype, b.dtype)
    return np.divide(a, b, out=np.zeros(a.shape, dtype=out_dtype), where=b != 0)

# %% ../nbs/losses.ipynb 7
def _metric_protections(
    y: np.ndarray, y_hat: np.ndarray, weights: Optional[np.ndarray] = None
) -> None:
    if weights is None:
        return
    if np.sum(weights) <= 0:
        raise ValueError("Sum of weights must be positive")
    if y.shape != y_hat.shape:
        raise ValueError(
            f"Wrong y_hat dimension. y_hat shape={y_hat.shape}, y shape={y.shape}"
        )
    if weights.shape != y.shape:
        raise ValueError(
            f"Wrong weight dimension. weights shape={weights.shape}, y shape={y.shape}"
        )

# %% ../nbs/losses.ipynb 11
def mae(
    y: np.ndarray,
    y_hat: np.ndarray,
    weights: Optional[np.ndarray] = None,
    axis: Optional[int] = None,
) -> Union[float, np.ndarray]:
    """Mean Absolute Error (MAE)

    MAE measures the relative prediction
    accuracy of a forecasting method by calculating the
    deviation of the prediction and the true
    value at a given time and averages these devations
    over the length of the series.

    Parameters
    ----------
    y : numpy array
        Observed values.
    y_hat : numpy array
        Predicted values.
    weights : numpy array, optional (default=None)
        Weights for weighted average.
    axis : int, optional (default=None)
        Axis or axes along which to average a.
        The default, axis=None, will average over all of the elements of
        the input array. If axis is negative it counts from last to first.

    Returns
    -------
    numpy array or double
        MAE along the specified axis.
    """
    _metric_protections(y, y_hat, weights)

    delta_y = np.abs(y - y_hat)
    if weights is not None:
        mae = np.average(
            delta_y[~np.isnan(delta_y)], weights=weights[~np.isnan(delta_y)], axis=axis
        )
    else:
        mae = np.nanmean(delta_y, axis=axis)
    return mae

# %% ../nbs/losses.ipynb 15
def mse(
    y: np.ndarray,
    y_hat: np.ndarray,
    weights: Optional[np.ndarray] = None,
    axis: Optional[int] = None,
) -> Union[float, np.ndarray]:
    """Mean Squared Error (MSE)

    MSE measures the relative prediction
    accuracy of a forecasting method by calculating the
    squared deviation of the prediction and the true
    value at a given time, and averages these devations
    over the length of the series.

    Parameters
    ----------
    y : numpy array
        Actual test values.
    y_hat : numpy array
        Predicted values.
    weights : numpy array, optional (default=None)
        Weights for weighted average.
    axis : int, optional (default=None)
        Axis or axes along which to average a.
        The default, axis=None, will average over all of the
        elements of the input array. If axis is negative it counts
        from the last to the first axis.

    Returns
    -------
    numpy array or double
        MSE along the specified axis.
    """
    _metric_protections(y, y_hat, weights)

    delta_y = np.square(y - y_hat)
    if weights is not None:
        mse = np.average(
            delta_y[~np.isnan(delta_y)], weights=weights[~np.isnan(delta_y)], axis=axis
        )
    else:
        mse = np.nanmean(delta_y, axis=axis)

    return mse

# %% ../nbs/losses.ipynb 19
def rmse(
    y: np.ndarray,
    y_hat: np.ndarray,
    weights: Optional[np.ndarray] = None,
    axis: Optional[int] = None,
) -> Union[float, np.ndarray]:
    """Root Mean Squared Error (RMSE)

    RMSE measures the relative prediction
    accuracy of a forecasting method by calculating the squared deviation
    of the prediction and the observed value at a given time and
    averages these devations over the length of the series.
    Finally the RMSE will be in the same scale
    as the original time series so its comparison with other
    series is possible only if they share a common scale.
    RMSE has a direct connection to the L2 norm.

    Parameters
    ----------
    y : numpy array
        Observed values.
    y_hat : numpy array
        Predicted values.
    weights : numpy array, optional (default=None)
        Weights for weighted average.
    axis : int, optional (default=None)
        Axis or axes along which to average a.
        The default, axis=None, will average over all of the elements of
        the input array. If axis is negative it counts from the last to first.

    Returns
    -------
    numpy array or double
        RMSE along the specified axis.
    """

    return np.sqrt(mse(y, y_hat, weights, axis))

# %% ../nbs/losses.ipynb 24
def mape(
    y: np.ndarray,
    y_hat: np.ndarray,
    weights: Optional[np.ndarray] = None,
    axis: Optional[int] = None,
) -> Union[float, np.ndarray]:
    """Mean Absolute Percentage Error (MAPE)

    MAPE measures the relative prediction
    accuracy of a forecasting method by calculating the percentual deviation
    of the prediction and the observed value at a given time and
    averages these devations over the length of the series.
    The closer to zero an observed value is, the higher penalty MAPE loss
    assigns to the corresponding error.

    Parameters
    ----------
    y : numpy array
        Observed values.
    y_hat : numpy array
        Predicted values.
    weights : numpy array, optional (default=None)
        Weights for weighted average.
    axis : int, optional (default=None)
        Axis or axes along which to average a.
        The default, axis=None, will average over all of the elements of
        the input array. If axis is negative it counts from the last to first.

    Returns
    -------
    numpy array or double
        MAPE along the specified axis.
    """
    _metric_protections(y, y_hat, weights)

    delta_y = np.abs(y - y_hat)
    scale = np.abs(y)
    mape = _divide_no_nan(delta_y, scale)
    mape = np.average(mape, weights=weights, axis=axis)
    mape = 100 * mape

    return mape

# %% ../nbs/losses.ipynb 27
def smape(
    y: np.ndarray,
    y_hat: np.ndarray,
    weights: Optional[np.ndarray] = None,
    axis: Optional[int] = None,
) -> Union[float, np.ndarray]:
    """Symmetric Mean Absolute Percentage Error (SMAPE)

    SMAPE measures the relative prediction
    accuracy of a forecasting method by calculating the relative deviation
    of the prediction and the observed value scaled by the sum of the
    absolute values for the prediction and observed value at a
    given time, then averages these devations over the length
    of the series. This allows the SMAPE to have bounds between
    0% and 200% which is desireble compared to normal MAPE that
    may be undetermined when the target is zero.


    Parameters
    ----------
    y : numpy array
        Observed values.
    y_hat : numpy array
        Predicted values.
    weights : numpy array, optional (default=None)
        Weights for weighted average.
    axis : None or int, optional (default=None)
        Axis or axes along which to average a.
        The default, axis=None, will average over all of the elements of
        the input array. If axis is negative it counts from the last to first.

    Returns
    -------
    numpy array or double
        SMAPE along the specified axis.
    """
    _metric_protections(y, y_hat, weights)

    delta_y = np.abs(y - y_hat)
    scale = np.abs(y) + np.abs(y_hat)
    smape = _divide_no_nan(delta_y, scale)
    smape = 200 * np.average(smape, weights=weights, axis=axis)

    if isinstance(smape, float):
        assert smape <= 200, "SMAPE should be lower than 200"
    else:
        assert all(smape <= 200), "SMAPE should be lower than 200"

    return smape

# %% ../nbs/losses.ipynb 32
def mase(
    y: np.ndarray,
    y_hat: np.ndarray,
    y_train: np.ndarray,
    seasonality: int,
    weights: Optional[np.ndarray] = None,
    axis: Optional[int] = None,
) -> Union[float, np.ndarray]:
    """Mean Absolute Scaled Error (MASE)

    MASE measures the relative prediction
    accuracy of a forecasting method by comparinng the mean absolute errors
    of the prediction and the observed value against the mean
    absolute errors of the seasonal naive model.
    The MASE partially composed the Overall Weighted Average (OWA),
    used in the M4 Competition.

    Parameters
    ----------
    y : numpy array
        Observed values.
    y_hat : numpy array
        Predicted values.
    y_train : numpy array
        Actual insample Seasonal Naive predictions.
    seasonality : int
        Main frequency of the time series;
        Hourly 24, Daily 7, Weekly 52, Monthly 12, Quarterly 4, Yearly 1.
    weights : numpy array, optional (default=None)
        Weights for weighted average.
    axis : int, optional (default=None)
        Axis or axes along which to average a.
        The default, axis=None, will average over all of the elements of
        the input array. If axis is negative it counts from the last to first.

    Returns
    -------
    numpy array or double
        MASE along the specified axis.

    References
    ----------
    [1] https://robjhyndman.com/papers/mase.pdf
    """
    delta_y = np.abs(y - y_hat)
    delta_y = np.average(delta_y, weights=weights, axis=axis)

    scale = np.abs(y_train[:-seasonality] - y_train[seasonality:])
    scale = np.average(scale, axis=axis)

    mase = delta_y / scale

    return mase

# %% ../nbs/losses.ipynb 36
def rmae(
    y: np.ndarray,
    y_hat1: np.ndarray,
    y_hat2: np.ndarray,
    weights: Optional[np.ndarray] = None,
    axis: Optional[int] = None,
) -> Union[float, np.ndarray]:
    """Relative Mean Absolute Error (RMAE)

    Calculates the RAME between two sets of forecasts (from two different forecasting methods).
    A number smaller than one implies that the forecast in the
    numerator is better than the forecast in the denominator.

    Parameters
    ----------
    y : numpy array
        Observed values.
    y_hat1 : numpy array
        Predicted values of first model.
    y_hat2 : numpy array
        Predicted values of baseline model.
    weights : numpy array, optional (default=None)
        Weights for weighted average.
    axis : int, optional (default=None)
        Axis or axes along which to average a.
        The default, axis=None, will average over all of the elements of
        the input array. If axis is negative it counts from the last to first.

    Returns
    -------
    numpy array or double
        RMAE along the specified axis.
    """
    numerator = mae(y=y, y_hat=y_hat1, weights=weights, axis=axis)
    denominator = mae(y=y, y_hat=y_hat2, weights=weights, axis=axis)
    rmae = numerator / denominator

    return rmae

# %% ../nbs/losses.ipynb 41
def quantile_loss(
    y: np.ndarray,
    y_hat: np.ndarray,
    q: float = 0.5,
    weights: Optional[np.ndarray] = None,
    axis: Optional[int] = None,
) -> Union[float, np.ndarray]:
    """Quantile Loss (QL)

    QL measures the deviation of a quantile forecast.
    By weighting the absolute deviation in a non symmetric way, the
    loss pays more attention to under or over estimation.
    A common value for q is 0.5 for the deviation from the median.

    Parameters
    ----------
    y : numpy array
        Observed values.
    y_hat : numpy array
        Predicted values.
    q : float (default=0.5)
        Quantile for the predictions' comparison.
    weights : numpy array, optional (default=None)
        Weights for weighted average.
    axis : int, optional (default=None)
        Axis or axes along which to average a.
        The default, axis=None, will average over all of the elements of
        the input array. If axis is negative it counts from the last to first.

    Returns
    -------
    numpy array or double
        QL along the specified axis.
    """
    _metric_protections(y, y_hat, weights)

    delta_y = y - y_hat
    loss = np.maximum(q * delta_y, (q - 1) * delta_y)

    if weights is not None:
        quantile_loss = np.average(
            loss[~np.isnan(loss)], weights=weights[~np.isnan(loss)], axis=axis
        )
    else:
        quantile_loss = np.nanmean(loss, axis=axis)

    return quantile_loss

# %% ../nbs/losses.ipynb 45
def mqloss(
    y: np.ndarray,
    y_hat: np.ndarray,
    quantiles: np.ndarray,
    weights: Optional[np.ndarray] = None,
    axis: Optional[int] = None,
) -> Union[float, np.ndarray]:
    """Multi-Quantile loss (MQL)

    MQL calculates the average multi-quantile Loss for
    a given set of quantiles, based on the absolute
    difference between predicted quantiles and observed values.

    The limit behavior of MQL allows to measure the accuracy
    of a full predictive distribution $\mathbf{\hat{F}}_{\\tau}$ with
    the continuous ranked probability score (CRPS). This can be achieved
    through a numerical integration technique, that discretizes the quantiles
    and treats the CRPS integral with a left Riemann approximation, averaging over
    uniformly distanced quantiles.

    Parameters
    ----------
    y : numpy array
        Observed values.
    y_hat : numpy array
        Predicted values.
    quantiles : numpy array
        Quantiles to compare against.
    weights : numpy array, optional (default=None)
        Weights for weighted average.
    axis : int, optional (default=None)
        Axis or axes along which to average a.
        The default, axis=None, will average over all of the elements of
        the input array. If axis is negative it counts from the last to first.

    Returns
    -------
    numpy array or double
        MQL along the specified axis.

    References
    ----------
    [1] https://www.jstor.org/stable/2629907
    """
    if weights is None:
        weights = np.ones(y.shape)

    _metric_protections(y, y_hat, weights)
    n_q = len(quantiles)

    y_rep = np.expand_dims(y, axis=-1)
    error = y_rep - y_hat
    mqloss = np.maximum(quantiles * error, (quantiles - 1) * error)

    # Match y/weights dimensions and compute weighted average
    weights = np.repeat(np.expand_dims(weights, axis=-1), repeats=n_q, axis=-1)
    mqloss = np.average(mqloss, weights=weights, axis=axis)

    return mqloss

# %% ../nbs/losses.ipynb 48
def coverage(
    y: np.ndarray,
    y_hat_lo: np.ndarray,
    y_hat_hi: np.ndarray,
) -> Union[float, np.ndarray]:
    """
    Coverage of y with y_hat_lo and y_hat_hi.

    Parameters
    ----------
    y : numpy array
        Observed values.
    y_hat_lo : numpy array
        Lower prediction interval.
    y_hat_hi : numpy array
        Higher prediction interval.

    Returns
    -------
    numpy array or double
        Coverage of y_hat

    References
    ----------
    [1] https://www.jstor.org/stable/2629907
    """
    return 100 * np.logical_and(y >= y_hat_lo, y <= y_hat_hi).mean()

# %% ../nbs/losses.ipynb 51
def calibration(
    y: np.ndarray,
    y_hat_hi: np.ndarray,
) -> Union[float, np.ndarray]:
    """
    Fraction of y that is lower than y_hat_hi.

    Parameters
    ----------
    y : numpy array
        Observed values.
    y_hat_hi : numpy array
        Higher prediction interval.

    Returns
    -------
    numpy array or double
        Calibration of y_hat

    References
    ----------
    [1] https://www.jstor.org/stable/2629907
    """
    return (y <= y_hat_hi).mean()

# %% ../nbs/losses.ipynb 54
def scaled_crps(
    y: np.ndarray,
    y_hat: np.ndarray,
    quantiles: np.ndarray,
    weights: Optional[np.ndarray] = None,
    axis: Optional[int] = None,
) -> Union[float, np.ndarray]:
    """Scaled Continues Ranked Probability Score

    Calculates a scaled variation of the CRPS, as proposed by Rangapuram (2021),
    to measure the accuracy of predicted quantiles `y_hat` compared to the observation `y`.
    This metric averages percentual weighted absolute deviations as
    defined by the quantile losses.


    Parameters
    ----------
    y : numpy array
        Observed values.
    y_hat : numpy array
        Predicted values.
    quantiles : numpy array
        Quantiles to compare against.
    weights : numpy array, optional (default=None)
        Weights for weighted average.
    axis : int, optional (default=None)
        Axis or axes along which to average a.
        The default, axis=None, will average over all of the elements of
        the input array. If axis is negative it counts from the last to first.

    Returns
    -------
    numpy array or double.
        Scaled crps along the specified axis.

    References
    ----------
    [1] https://proceedings.mlr.press/v139/rangapuram21a.html
    """
    eps = np.finfo(float).eps
    norm = np.sum(np.abs(y))
    loss = mqloss(y=y, y_hat=y_hat, quantiles=quantiles, weights=weights, axis=axis)
    loss = 2 * loss * np.sum(np.ones(y.shape)) / (norm + eps)
    return loss
