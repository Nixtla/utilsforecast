# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/feature_engineering.ipynb.

# %% auto 0
__all__ = ['fourier']

# %% ../nbs/feature_engineering.ipynb 3
from typing import Tuple

import numpy as np

import utilsforecast.processing as ufp
from .compat import DataFrame
from .validation import validate_format, validate_freq

# %% ../nbs/feature_engineering.ipynb 4
def fourier(
    df: DataFrame,
    freq: str,
    season_length: int,
    k: int,
    h: int = 0,
    id_col: str = "unique_id",
    time_col: str = "ds",
) -> Tuple[DataFrame, DataFrame]:
    """Compute fourier seasonal terms for training and forecasting

    Parameters
    ----------
    df : pandas or polars DataFrame
        Dataframe with ids, times and values for the exogenous regressors.
    freq : str or int
        Frequency of the data. Must be a valid pandas or polars offset alias, or an integer.
    season_length : int
        Number of observations per unit of time. Ex: 24 Hourly data.
    k : int
        Maximum order of the fourier terms
    h : int (default=0)
        Forecast horizon.
    id_col : str (default='unique_id')
        Column that identifies each serie.
    time_col : str (default='ds')
        Column that identifies each timestep, its values can be timestamps or integers.

    Returns
    -------
    transformed_df : pandas or polars DataFrame
        Original DataFrame with the computed features
    future_df : pandas or polars DataFrame
        DataFrame with future values
    """
    if not isinstance(h, int) or h < 0:
        raise ValueError("`h` must be a non-negative integer")
    validate_format(df, id_col, time_col, None)
    validate_freq(df[time_col], freq)

    # compute terms based on the max size
    id_counts = ufp.counts_by_id(df, id_col)
    uids = id_counts[id_col]
    sizes = id_counts["counts"].to_numpy()
    max_size = sizes.max()
    # taken from: https://github.com/tblume1992/TSUtilities/blob/main/TSUtilities/TSFeatures/fourier_seasonality.py
    x = 2 * np.pi * np.arange(1, k + 1) / season_length
    x = x.astype(np.float32)
    t = np.arange(1, max_size + 1 + h, dtype=np.float32)
    x = x * t[:, None]
    terms = np.hstack([np.sin(x), np.cos(x)])
    cols = [f"{op}{i+1}_{season_length}" for op in ("sin", "cos") for i in range(k)]

    # slice for each serie
    vals = np.empty((sizes.sum(), 2 * k), dtype=np.float32)
    future_vals = np.empty((h * sizes.size, 2 * k), dtype=np.float32)
    start = 0
    for i, size in enumerate(sizes):
        vals[start : start + size, :] = terms[:size]
        future_vals[i * h : (i + 1) * h] = terms[size : size + h]
        start += size

    # assign back to df
    sort_idxs = ufp.maybe_compute_sort_indices(df, id_col, time_col)
    times = df[time_col]
    if sort_idxs is not None:
        restore_idxs = np.empty_like(sort_idxs)
        restore_idxs[sort_idxs] = np.arange(sort_idxs.size)
        vals = vals[restore_idxs]
        times = ufp.take_rows(times, sort_idxs)
    last_times = ufp.take_rows(times, sizes.cumsum() - 1)
    df = ufp.copy_if_pandas(df, deep=False)
    transformed = ufp.assign_columns(df, cols, vals)

    if h == 0:
        return transformed, type(df)({})

    # future vals
    future_df = ufp.make_future_dataframe(
        uids=uids,
        last_times=last_times,
        freq=freq,
        h=h,
        id_col=id_col,
        time_col=time_col,
    )
    future_df = ufp.assign_columns(future_df, cols, future_vals)
    return transformed, future_df
